# -*- coding: utf-8 -*-
"""MyUnet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uZmepPW4Rn2SWwzjmPsfWXzk7BOADABc
"""

import numpy as np
import nibabel as nib
from google.colab import files


uploaded = files.upload()

import numpy as np
import nibabel as nib
from google.colab import files
from PIL import Image
from matplotlib import pyplot as plt

#uploaded = files.upload()
#cargar
#img = nib.load('../content/training_axial_crop_pat0.nii')
#img1 = nib.load('../content/training_axial_crop_pat1.nii')

#a = np.array(img.dataobj)
#b = np.array(img1.dataobj)

#-------------------------------------------------------------

smooth = 1.
#img_rows = 128
img_rows = 128
#img_cols = 151
img_cols = 160


#plt.imshow(img, cmap=plt.cm.gray)
#plt.show()

#read image 3d
img_training = nib.load('../content/training_sa_crop_pat0.nii')
img_label = nib.load('../content/training_sa_crop_pat0-label.nii')

#create numpy array 
array_training = np.array(img_training.dataobj)
array_label = np.array(img_label.dataobj)

print("Dimensioni dell'array training prima dello swap: ",array_training.shape)
print("Dimensioni dell'array label prima dello swap: ",array_training.shape)
array_training = np.swapaxes(array_training,0,1)
array_label = np.swapaxes(array_label,0,1)
print("Dimensioni dell'array training dopo lo swap: ",array_training.shape)
print("Dimensioni dell'array label dopo lo swap: ",array_training.shape)


import matplotlib.pyplot as plt
plt.imshow(array_training[108,::])


#resized_array_training = np.resize(array_training, (127, 224, 160))
#resized_array_label = np.resize(array_label, (127, 224, 160))



#from scipy.ndimage import zoom
#resized_array_training = zoom(array_training, (1.08, 1, 1.06))
#resized_array_label= zoom(array_label, (1.08, 1, 1.06))
resized_array_training = zoom(array_training, (1, 1.007, 1.06))
resized_array_label= zoom(array_label, (1, 1.007, 1.06))

print("Dimensioni dell'array training dopo il resize: ", resized_array_training.shape)
print("Dimensioni dell'array label dopo il resize: ", resized_array_label.shape)

import matplotlib.pyplot as plt
plt.imshow(resized_array_training[108,:,:])

import os
from google.colab import drive
import numpy as np
from google.colab.patches import cv2_imshow
from keras import backend as K
from keras import layers
from keras.layers import Activation
from keras.layers import Input, Conv2D, ZeroPadding2D, MaxPooling2D, UpSampling2D, concatenate
from keras.layers.normalization import BatchNormalization
from keras.models import Model
from keras.optimizers import Adam
from PIL import Image
from keras.preprocessing.image import load_img


#array_training = array_training.reshape((1, array_training.shape[0], array_training.shape[1],1))
resized_array_training = resized_array_training.reshape((resized_array_training.shape[0], resized_array_training.shape[1], resized_array_training.shape[2],1))
resized_array_training = resized_array_training.astype('float32')


mean = np.mean(resized_array_training)
std = np.std(resized_array_training)

resized_array_training -= mean
resized_array_training /= std


def dice_coef(y_true, y_pred):
    y_true_f = K.flatten(y_true)
    y_pred_f = K.flatten(y_pred)
    intersection = K.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)
  
def dice_coef_loss(y_true, y_pred):
    return -dice_coef(y_true, y_pred)
  
def up_conv_block(input_tensor, kernel_size, filters, stage, block, strides=(1, 1)):
  filters1, filters2, filters3 = filters
  if K.image_data_format() == 'channels_last':
      bn_axis = 3
  else:
      bn_axis = 1
  up_conv_name_base = 'up' + str(stage) + block + '_branch'
  conv_name_base = 'res' + str(stage) + block + '_branch'
  bn_name_base = 'bn' + str(stage) + block + '_branch'

  x = UpSampling2D(size=(2, 2), name=up_conv_name_base + '2a')(input_tensor)

  x = Conv2D(filters1, (1, 1), strides=strides, name=conv_name_base + '2a')(x)

  x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2a')(x)
  x = Activation('relu')(x)

  x = Conv2D(filters2, kernel_size, padding='same', name=conv_name_base + '2b')(x)
  x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2b')(x)
  x = Activation('relu')(x)

  x = Conv2D(filters3, (1, 1), name=conv_name_base + '2c')(x)
  x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2c')(x)

  shortcut = UpSampling2D(size=(2, 2), name=up_conv_name_base + '1')(input_tensor)
  shortcut = Conv2D(filters3, (1, 1), strides=strides, name=conv_name_base + '1')(shortcut)
  shortcut = BatchNormalization(axis=bn_axis, name=bn_name_base + '1')(shortcut)

  x = layers.add([x, shortcut])
  x = Activation('relu')(x)
  return x
  
def identity_block(input_tensor, kernel_size, filters, stage, block):
    filters1, filters2, filters3 = filters
    if K.image_data_format() == 'channels_last':
        bn_axis = 3
    else:
        bn_axis = 1
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'

    x = Conv2D(filters1, (1, 1), name=conv_name_base + '2a')(input_tensor)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2a')(x)
    x = Activation('relu')(x)

    x = Conv2D(filters2, kernel_size, padding='same', name=conv_name_base + '2b')(x)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2b')(x)
    x = Activation('relu')(x)

    x = Conv2D(filters3, (1, 1), name=conv_name_base + '2c')(x)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2c')(x)

    x = layers.add([x, input_tensor])
    x = Activation('relu')(x)
    return x


def conv_block(input_tensor, kernel_size, filters, stage, block, strides=(2, 2)):
    filters1, filters2, filters3 = filters
    if K.image_data_format() == 'channels_last':
        bn_axis = 3
    else:
        bn_axis = 1
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'

    x = Conv2D(filters1, (1, 1), strides=strides, name=conv_name_base + '2a')(input_tensor)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2a')(x)
    x = Activation('relu')(x)

    x = Conv2D(filters2, kernel_size, padding='same', name=conv_name_base + '2b')(x)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2b')(x)
    x = Activation('relu')(x)

    x = Conv2D(filters3, (1, 1), name=conv_name_base + '2c')(x)
    x = BatchNormalization(axis=bn_axis, name=bn_name_base + '2c')(x)

    shortcut = Conv2D(filters3, (1, 1), strides=strides, name=conv_name_base + '1')(input_tensor)
    shortcut = BatchNormalization(axis=bn_axis, name=bn_name_base + '1')(shortcut)

    x = layers.add([x, shortcut])
    x = Activation('relu')(x)
    return x
  
def get_resnet(f=16, bn_axis=3, classes=1):
  
  input = Input((img_rows, img_cols, 1))
  x = ZeroPadding2D((4, 4))(input)
  x = Conv2D(f, (7, 7), strides=(2, 2), name='conv1')(x)
  x = BatchNormalization(axis=bn_axis, name='bn_conv1')(x)
  x = Activation('relu')(x)
  x = MaxPooling2D((3, 3), strides=(2, 2))(x)
  print("dimensione output primo strato: ", x.shape)

  x = conv_block(x, 3, [f, f, f * 2], stage=2, block='a', strides=(1, 1))
  x = identity_block(x, 3, [f, f, f * 2], stage=2, block='b')
  x2 = identity_block(x, 3, [f, f, f * 2], stage=2, block='c')
  print("dimensione output secondo strato: ", x.shape)

  x = conv_block(x2, 3, [f * 2, f * 2, f * 4], stage=3, block='a')
  x = identity_block(x, 3, [f * 2, f * 2, f * 4], stage=3, block='b')
  x3 = identity_block(x, 3, [f * 2, f * 2, f * 4], stage=3, block='d')
  print("dimensione output terzo strato: ", x.shape)

  x = conv_block(x3, 3, [f * 4, f * 4, f * 8], stage=4, block='a')
  x = identity_block(x, 3, [f * 4, f * 4, f * 8], stage=4, block='b')
  x4 = identity_block(x, 3, [f * 4, f * 4, f * 8], stage=4, block='f')
  print("dimensione output quarto strato: ", x.shape)

  x = conv_block(x4, 3, [f * 8, f * 8, f * 16], stage=5, block='a')
  x = identity_block(x, 3, [f * 8, f * 8, f * 16], stage=5, block='b')
  x = identity_block(x, 3, [f * 8, f * 8, f * 16], stage=5, block='c')
  print("dimensione output quinto strato: ", x.shape)

  x = up_conv_block(x, 3, [f * 16, f * 8, f * 8], stage=6, block='a')
  x = identity_block(x, 3, [f * 16, f * 8, f * 8], stage=6, block='b')
  x = identity_block(x, 3, [f * 16, f * 8, f * 8], stage=6, block='c')
  print("dimensione output sesto strato: ", x.shape)
  
  

  x = concatenate([x, x4], axis=bn_axis)

  x = up_conv_block(x, 3, [f * 16, f * 4, f * 4], stage=7, block='a')
  x = identity_block(x, 3, [f * 16, f * 4, f * 4], stage=7, block='b')

  x = identity_block(x, 3, [f * 16, f * 4, f * 4], stage=7, block='f')

  x = concatenate([x, x3], axis=bn_axis)

  x = up_conv_block(x, 3, [f * 8, f * 2, f * 2], stage=8, block='a')
  x = identity_block(x, 3, [f * 8, f * 2, f * 2], stage=8, block='b')
  x = identity_block(x, 3, [f * 8, f * 2, f * 2], stage=8, block='d')

  x = concatenate([x, x2], axis=bn_axis)

  x = up_conv_block(x, 3, [f * 4, f, f], stage=10, block='a', strides=(1, 1))
  x = identity_block(x, 3, [f * 4, f, f], stage=10, block='b')
  x = identity_block(x, 3, [f * 4, f, f], stage=10, block='c')

  x = UpSampling2D(size=(2, 2))(x)
  x = Conv2D(classes, (3, 3), padding='same', activation='sigmoid', name='convLast')(x)

  model = Model(input, x, name='resnetUnet')
  model.compile(optimizer=Adam(lr=3e-5), loss=dice_coef_loss,
                metrics=[dice_coef])
     # model.compile(optimizer=Adam(lr=3e-4), loss=dice_coef_loss,
      #          metrics=[dice_coef, 'accuracy', precision, recall, f1score])

  model.summary()
  return model

model = get_resnet(f=16, bn_axis=3, classes=1)

print("Dimensione resized array training ",resized_array_training.shape)
print("Dimensione resized array label ",resized_array_label.shape)

x_train = resized_array_training[0:144]
x_test = resized_array_training[145:207]
y_train = resized_array_label[0:144]
y_test = resized_array_label[145:207]


print("Dimensione x train",x_train.shape)
print("Dimensione x test ",x_test.shape)
print("Dimensione y train",y_train.shape)
print("Dimensione y test ",y_test.shape)





results = model.fit(x_train, y_train, batch_size=16, epochs=3)

import matplotlib.pyplot as plt
predicted_image = model.predict(x_test, verbose = 0)
image = (predicted_image[61][:, :, 0] * 255.).astype(np.uint8)
img = Image.fromarray(image)
plt.imshow(img, cmap=plt.cm.gray)
plt.show()